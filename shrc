# =============================================================================
# SHELL CONFIGURATION (ZSH & BASH)
# =============================================================================

# Return immediately if the shell is not interactive (e.g., scp or scripts)
[[ $- != *i* ]] && return

# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================

# Set the default language and character encoding to UTF-8
export LANG="${LANG:-en_US.UTF-8}"
export LC_ALL="${LC_ALL:-en_US.UTF-8}"

# Define the location for custom tool configurations
export RIPGREP_CONFIG_PATH=~/.sidorenko_dotfiles/ripgreprc
export TIGRC_USER=~/.sidorenko_dotfiles/tigrc

# Editor selection logic: prefer Neovim, then Vim, then Vi
if command -v nvim >/dev/null 2>&1; then
  export EDITOR="nvim"
elif command -v vim >/dev/null 2>&1; then
  export EDITOR="vim"
else
  export EDITOR="vi"
fi
export VISUAL="$EDITOR"

# Set default file permissions (755 for dirs, 644 for files)
umask 022

# Detect macOS for specific alias handling
__is_macos=false
[[ "$OSTYPE" == "darwin"* ]] && __is_macos=true

# =============================================================================
# PATH MANAGEMENT
# =============================================================================
if [ -e "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh" ]; then
  # This script automatically prepends ~/.nix-profile/bin to your PATH
  source "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh"
fi

path_prepend() { [[ -d "$1" ]] && PATH="$1:${PATH}"; }
path_append()  { [[ -d "$1" ]] && PATH="${PATH}:$1"; }

path_prepend "$HOME/.sidorenko_dotfiles/bin"
path_prepend "$HOME/.local/bin"
path_prepend "$HOME/bin"
path_prepend "$HOME/.cargo/bin"
path_prepend "$HOME/go/bin"
path_prepend "$HOME/.npm-global/bin"
path_prepend "$HOME/.asdf/bin"
path_prepend "$HOME/.asdf/shims"

# =============================================================================
# SHELL SPECIFIC LOGIC
# =============================================================================

if [ -n "$ZSH_VERSION" ]; then
    # -------------------------------------------------------------------------
    # ZSH CONFIGURATION
    # -------------------------------------------------------------------------

    # --- Options ---
    setopt autocd                   # Change directory just by typing the name
    setopt correct                  # Auto-correct spelling mistakes in commands
    setopt extended_glob            # Enable advanced globbing (like ^ for negation)
    setopt interactive_comments     # Allow comments (#) in interactive shell line
    unsetopt case_glob              # Ignore case when using glob patterns
    unsetopt beep                   # Disable the bell globally (silence)
    unsetopt list_beep              # Disable the bell specifically for ambiguous completion

    # --- History (Zsh Native) ---
    export HISTSIZE=200000
    export SAVEHIST=400000
    export HISTFILE="${HOME}/.zsh_history"
    setopt append_history           # Append to history file instead of overwriting
    setopt inc_append_history       # Write to file immediately after execution
    setopt share_history            # Share history instantly between running sessions
    setopt hist_ignore_all_dups     # Remove older duplicate entries from history
    setopt hist_ignore_space        # Ignore commands starting with a space
    setopt hist_reduce_blanks       # Trim extra spaces before recording
    setopt hist_verify              # Show command to user before running history expansion

    # Match Bash's HISTIGNORE behavior (don't save common short commands)
    zshaddhistory() {
        emulate -L zsh
        local line=${1%%$'\n'}
        # List of commands to ignore
        [[ "$line" == "ls" ]] && return 1
        [[ "$line" == "l" ]] && return 1
        [[ "$line" == "ll" ]] && return 1
        [[ "$line" == "la" ]] && return 1
        [[ "$line" == "pwd" ]] && return 1
        [[ "$line" == "cd" ]] && return 1
        [[ "$line" == "cd -" ]] && return 1
        [[ "$line" == "exit" ]] && return 1
        [[ "$line" == "clear" ]] && return 1
        [[ "$line" == "history" ]] && return 1
        return 0
    }

    # --- Completion ---
    autoload -Uz compinit && compinit
    
    # Enable case-insensitive completion
    zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
    # Enable a selection menu for ambiguous options
    zstyle ':completion:*' menu select
    # Allow variable expansion during completion
    setopt glob_complete
    # Sort files by name and mark symlinked dirs with a slash
    zstyle ':completion:*' file-sort name

    # --- Key Bindings ---
    bindkey -e  # Emacs mode
    
    # History search based on current input
    autoload -U up-line-or-beginning-search
    autoload -U down-line-or-beginning-search
    zle -N up-line-or-beginning-search
    zle -N down-line-or-beginning-search
    
    bindkey "^[[A" up-line-or-beginning-search
    bindkey "^[[B" down-line-or-beginning-search

    # --- Prompt (Zsh Native) ---
    setopt prompt_subst
    
    # Set window title
    precmd() { print -Pn "\e]0;%n@%m: %~\a"; }
    
    # Structure: [ExitCode] User@Host Path
    # Colors: User=BoldGreen, Host=BoldBlue, Path=Cyan, Exit=Red
    # Path: %3~ means "show last 3 directories" (matches Bash PROMPT_DIRTRIM=3)
    local exit_code="%(?::%B%F{red}✘%?%f%b )"
    PS1="${exit_code}%B%F{green}%n%f%b@%B%F{blue}%m%f%b %F{cyan}%3~%f"$'\n'"%B$ %b"

    # --- Integrations ---
    # Load kubectl completion
    if command -v kubectl >/dev/null 2>&1; then
        source <(kubectl completion zsh)
    fi

    # Load direnv
    if command -v direnv >/dev/null 2>&1; then
        eval "$(direnv hook zsh)"
    fi

    # Load zoxide
    eval "$(zoxide init zsh)"

    # Load FZF
    source <(fzf --zsh)

elif [ -n "$BASH_VERSION" ]; then
    # -------------------------------------------------------------------------
    # BASH CONFIGURATION
    # -------------------------------------------------------------------------

    # --- Options ---
    shopt -s autocd                 # Change directory by typing directory name
    shopt -s cdspell                # Auto-correct minor directory typos
    shopt -s checkwinsize           # Update window size after command execution
    shopt -s cmdhist                # Save multi-line commands as single history entry
    shopt -s histappend             # Append to history file, don't overwrite
    shopt -s globstar               # Enable recursive globbing with **
    shopt -s extglob                # Enable extended globbing patterns
    shopt -s nocaseglob             # Case-insensitive globbing
    shopt -s direxpand              # Expand variables during path completion
    shopt -s expand_aliases         # Expand aliases in non-interactive shells

    # --- History (Bash Native) ---
    export HISTSIZE=200000
    export HISTFILESIZE=400000
    export HISTCONTROL=ignoreboth:erasedups
    # Ignore specific short commands
    export HISTIGNORE="&:ls:l:ll:la:pwd:cd:cd -:exit:clear:history"
    export HISTTIMEFORMAT='%F %T  '
    
    # Sync history between terminals
    __bash_save_history() {
        history -a
        history -n
    }

    # --- Completion & Readline ---
    bind "set completion-ignore-case on"
    bind "set show-all-if-ambiguous on"
    bind "set mark-symlinked-directories on"
    
    # History search based on current input
    bind '"\e[A": history-search-backward'
    bind '"\e[B": history-search-forward'

    # Load bash_completion
    if [[ -r /usr/share/bash-completion/bash_completion ]]; then
        source /usr/share/bash-completion/bash_completion
    elif [[ -r /usr/local/etc/bash_completion ]]; then
        source /usr/local/etc/bash_completion
    fi
    complete -cf sudo 2>/dev/null || true

    # --- Prompt (Bash Native) ---
    # Trim directory path to last 3 elements
    export PROMPT_DIRTRIM=3

    __prompt_build() {
        local ec=$?
        local reset="\[\e[0m\]"
        local bold="\[\e[1m\]"
        local red="\[\e[1;31m\]"
        local green="\[\e[1;32m\]" # Bold Green
        local blue="\[\e[1;34m\]"  # Bold Blue
        local cyan="\[\e[36m\]"    # Cyan (non-bold to match Zsh defaults usually)
        local host="${HOSTNAME%%.*}"

        # Window title
        printf '\e]0;%s@%s: %s\a' "$USER" "$host" "${PWD/#$HOME/~}"

        # Exit code
        local ec_part=""
        if (( ec != 0 )); then
            ec_part="${red}✘${ec}${reset} "
        fi

        # Structure: [ExitCode] User@Host Path
        # Note: \u matches %n, \h matches %m, \w matches %3~ (due to PROMPT_DIRTRIM)
        PS1="${ec_part}${green}\u${reset}@${blue}${host}${reset} ${cyan}\w${reset}\n${bold}\$ ${reset}"
    }

    __prompt_command() {
        __bash_save_history
        __prompt_build
    }
    PROMPT_COMMAND="__prompt_command"

    # --- Integrations ---
    # Load kubectl completion
    if command -v kubectl >/dev/null 2>&1; then
        source <(kubectl completion bash) 2>/dev/null || true
    fi

    # Load direnv
    if command -v direnv >/dev/null 2>&1; then
        eval "$(direnv hook bash)"
    fi

    # Load zoxide
    eval "$(zoxide init bash)"

    # Load FZF
    eval "$(fzf --bash)"
fi

if $__is_macos; then
  [[ -d "/opt/homebrew/bin" ]] && path_prepend "/opt/homebrew/bin"
  [[ -d "/usr/local/bin" ]] && path_prepend "/usr/local/bin"
fi
export PATH
ppath() { tr ':' '\n' <<<"$PATH" | nl -ba; }

# =============================================================================
# REQUIRED TOOLS CHECK
# =============================================================================

__require_tools() {
  local missing=""
  local t
  for t in "$@"; do
    command -v "$t" >/dev/null 2>&1 || missing="${missing} $t"
  done
  if [[ -n "$missing" ]]; then
    echo "dotfiles: missing required tools:${missing}" >&2
    return 1
  fi
}

__require_tools \
  eza bat rg moor less zoxide fzf fd \
  delta duf ncdu tldr jq nvim pv tig git mc ranger direnv \
  ctags fish luarocks lua lazygit tectonic pdflatex mmdc curl

# =============================================================================
# COLORS AND COSMETICS
# =============================================================================
if command -v dircolors >/dev/null 2>&1; then
  eval "$(dircolors -b 2>/dev/null || true)"
fi

# Man page colors (Used by moor/bat)
export LESS_TERMCAP_mb=$'\e[1;31m'
export LESS_TERMCAP_md=$'\e[1;36m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;44;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;32m'

# =============================================================================
# ALIASES & MODERN REPLACEMENTS
# =============================================================================

# LS: Use 'eza'
alias ls='eza --group-directories-first'
alias ll='eza -lah --group-directories-first'
alias la='eza -a --group-directories-first'
alias l='eza -F --group-directories-first'

# CAT: Use 'bat'
alias cat='bat --paging=never -p'

# GREP: Use ripgrep
alias grep='rg --color=always'
alias egrep='rg --color=always'
alias fgrep='rg --color=always -F'

# PAGER: Use 'moor'
export PAGER="moor"
export MANPAGER="moor"
export MOOR="--no-linenumbers --statusbar=bold"
alias less='moor'

# Shortcuts
alias c='clear'
alias h='history'
alias j='jobs -l'
alias path='ppath'

alias rm='rm -I'
alias cp='cp -i'
alias mv='mv -i'

alias df='df -h'
alias du='du -h'
alias mkdir='mkdir -pv'

alias ebashrc='$EDITOR ~/.bashrc'
alias sbashrc='source ~/.bashrc'

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias sl='ls'
alias grpe='rg'
alias please='sudo $(fc -ln -1)'

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

psg() { ps aux | rg -i -- "$*"; }
top10() { ps aux --sort=-%mem | head -n 11; }
myip() { curl -fsSL https://ifconfig.me 2>/dev/null || curl -fsSL https://api.ipify.org; }
pingg() { ping -c 5 8.8.8.8; }

ports() {
  if command -v ss >/dev/null 2>&1; then
    ss -tulpn
  elif command -v netstat >/dev/null 2>&1; then
    netstat -tulpn
  else
    echo "ports: install ss (iproute2) or netstat" >&2
    return 1
  fi
}

if command -v journalctl >/dev/null 2>&1; then
  alias jctl='journalctl -xe --no-pager'
fi

mkcd() { mkdir -p -- "$1" && cd -- "$1"; }
cdf() { cd -- "$(dirname -- "$1")"; }
up() { local n=${1:-1}; while (( n-- > 0 )); do cd .. || return; done; }

extract() {
  [[ -f "$1" ]] || { echo "extract: file not found: $1" >&2; return 2; }
  case "$1" in
    *.tar.bz2) tar xjf "$1" ;;
    *.tar.gz)  tar xzf "$1" ;;
    *.tar.xz)  tar xJf "$1" ;;
    *.tar.zst) tar --zstd -xf "$1" ;;
    *.tar)     tar xf "$1" ;;
    *.tbz2)    tar xjf "$1" ;;
    *.tgz)     tar xzf "$1" ;;
    *.zip)     unzip "$1" ;;
    *.7z)      7z x "$1" ;;
    *.rar)     unrar x "$1" ;;
    *.gz)      gunzip "$1" ;;
    *.bz2)     bunzip2 "$1" ;;
    *.xz)      unxz "$1" ;;
    *) echo "extract: don't know how to extract '$1'" >&2; return 3 ;;
  esac
}

serve() {
  local port="${1:-8000}"
  if command -v python3 >/dev/null 2>&1; then
    python3 -m http.server "$port"
  elif command -v python >/dev/null 2>&1; then
    python -m SimpleHTTPServer "$port"
  else
    echo "serve: python not found" >&2
    return 1
  fi
}

timer() {
  local start end
  start="$(date +%s)"
  "$@"
  local ec=$?
  end="$(date +%s)"
  echo "Elapsed: $((end-start))s (exit $ec)"
  return $ec
}

cgr() {
  command -v git >/dev/null 2>&1 || return 1
  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null)" || { echo "Not in a git repo" >&2; return 2; }
  cd "$root" || return
}

pj() {
  if command -v jq >/dev/null 2>&1; then
    jq .
  else
    python3 -m json.tool
  fi
}

rgf() {
  rg --hidden --follow --smart-case --glob '!.git/' "$@"
}

whop() {
  local port="$1"
  [[ -n "$port" ]] || { echo "usage: whop <port>" >&2; return 2; }
  if command -v lsof >/dev/null 2>&1; then
    lsof -nP -iTCP:"$port" -sTCP:LISTEN
  elif command -v ss >/dev/null 2>&1; then
    ss -ltnp "sport = :$port"
  else
    echo "Install lsof or ss" >&2
    return 1
  fi
}

fkill() {
  local pat="${1:-}"
  [[ -n "$pat" ]] || { echo "usage: fkill <pattern>" >&2; return 2; }
  ps aux | fzf -i --header="select process to kill" | awk '{print $2}' | xargs -r kill -9
}

# =============================================================================
# GIT ALIASES
# =============================================================================
if command -v git >/dev/null 2>&1; then
  alias g='git'
  alias gs='git status -sb'
  alias ga='git add'
  alias gaa='git add -A'
  alias gc='git commit'
  alias gcm='git commit -m'
  alias gca='git commit --amend'
  alias gco='git checkout'
  alias gcb='git checkout -b'
  alias gb='git branch'
  alias gbd='git branch -d'
  alias gbs='git branch -vv'
  alias gl='git log --oneline --decorate --graph --all --date=short'
  alias gll='git log --stat --decorate'
  alias gd='git diff'
  alias gds='git diff --staged'
  alias gp='git push'
  alias gpf='git push --force-with-lease'
  alias gpl='git pull --rebase'
  alias gst='git stash'
  alias gstp='git stash pop'
  alias grh='git reset --hard'
  alias gclean='git clean -xfd'

fi

# =============================================================================
# TOOL ALIASES (DOCKER / K8S / TERRAFORM)
# =============================================================================
if command -v docker >/dev/null 2>&1; then
  alias d='docker'
  alias dps='docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"'
  alias dcu='docker compose up'
  alias dcd='docker compose down'
  alias dcl='docker compose logs -f --tail=200'
  alias dimg='docker images'
fi

if command -v kubectl >/dev/null 2>&1; then
  alias k='kubectl'
  alias kgp='kubectl get pods'
  alias kgs='kubectl get svc'
  alias kgn='kubectl get nodes -o wide'
  alias kctx='kubectl config current-context'
  alias kns='kubectl config set-context --current --namespace'
fi

if command -v terraform >/dev/null 2>&1; then
  alias tf='terraform'
  alias tfi='terraform init'
  alias tfp='terraform plan'
  alias tfa='terraform apply'
  alias tfd='terraform destroy'
fi

# =============================================================================
# GPG & LOCAL CONFIG
# =============================================================================
export GPG_TTY="$(tty 2>/dev/null || true)"

[[ -r "$HOME/.bashrc.local" ]] && source "$HOME/.bashrc.local"
